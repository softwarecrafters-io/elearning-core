---
description: HTTP API design rules for REST endpoints
globs: ["**/infrastructure/http/**/*.ts", "**/*Controller.ts"]
alwaysApply: false
---

# HTTP API Design

## REST Simplified

Use resources with HTTP verbs. No HATEOAS.

### URL Structure

```
GET    /orders          # List orders
GET    /orders/:id      # Get single order
POST   /orders          # Create order
PUT    /orders/:id      # Update order
DELETE /orders/:id      # Delete order
```

### Naming Rules
- **Plural nouns** for resources: `/orders`, `/products`, `/customers`
- **Lowercase with hyphens**: `/order-items`, not `/orderItems`
- **No verbs in URLs**: Use HTTP methods instead

```typescript
// ❌ BAD
POST /createOrder
GET /getOrderById/:id

// ✅ GOOD
POST /orders
GET /orders/:id
```

---

## Response Format

### Success: Return the resource directly

```typescript
// GET /orders/123
{
  "id": "123",
  "status": "confirmed",
  "total": 150.00,
  "items": [...]
}

// POST /orders (201 Created)
{
  "id": "456",
  "status": "draft",
  ...
}

// DELETE /orders/123 (204 No Content)
// No body
```

### Error: Return error message

```typescript
// 400, 404, 422, etc.
{
  "error": "Product prod-123 not found"
}
```

---

## Status Codes

| Code | Use |
|------|-----|
| 200 | Success (GET, PUT, PATCH) |
| 201 | Created (POST) |
| 204 | No Content (DELETE) |
| 400 | Bad Request (malformed input, other errors) |
| 401 | Unauthorized (not authenticated) |
| 403 | Forbidden (not authorized) |
| 404 | Not Found |
| 422 | Unprocessable Entity (validation/business rule) |
| 500 | Internal Server Error |

---

## Input Validation

Validate **only types and nulls** in the Controller. Business rules are validated in the domain.

```typescript
// src/orders/infrastructure/http/OrderController.ts
class OrderController {
  async create(req: Request, res: Response): Promise<void> {
    // 1. Validate types and nulls (not business rules)
    const { productId, quantity } = req.body;
    if (!productId || typeof productId !== 'string') {
      return this.badRequest(res, 'productId is required');
    }
    if (typeof quantity !== 'number') {
      return this.badRequest(res, 'quantity must be a number');
    }

    // 2. Call UseCase - domain validates business rules (e.g. quantity > 0)
    try {
      const order = await this.createOrderUseCase.execute(productId, quantity);
      res.status(201).json(order);
    } catch (error) {
      this.handleError(error, res);
    }
  }

  private badRequest(res: Response, message: string): void {
    res.status(400).json({ error: message });
  }
}
```

```typescript
// ❌ BAD - Duplicates domain validation
if (quantity <= 0) {
  return this.badRequest(res, 'quantity must be positive');
}

// ✅ GOOD - Let PositiveNumber.create() validate this
// The UseCase will throw DomainError.createValidation() if invalid
```

---

## Error Handling in Controllers

Map DomainError types to HTTP status codes.

```typescript
import { DomainError } from '../../common/domain/DomainError';

class OrderController {
  // ... route handlers

  private handleError(error: unknown, res: Response): void {
    if (error instanceof DomainError) {
      const statusMap = {
        notFound: 404,
        validation: 422,
        other: 400,
      };
      const status = statusMap[error.type];
      res.status(status).json({ error: error.message });
      return;
    }
    // Technical error - log and return 500
    console.error(error);
    res.status(500).json({ error: 'Internal server error' });
  }
}
```

---

## Controller Structure

```typescript
class OrderController {
  constructor(
    private createOrderUseCase: CreateOrderUseCase,
    private getOrderUseCase: GetOrderUseCase
  ) {}

  // Route handlers
  async create(req: Request, res: Response): Promise<void> { ... }
  async getById(req: Request, res: Response): Promise<void> { ... }
  async list(req: Request, res: Response): Promise<void> { ... }

  // Private helpers
  private badRequest(res: Response, message: string): void { ... }
  private handleError(error: unknown, res: Response): void { ... }
}
```

---

## Non-Negotiable Rules

### ❌ I will NEVER:
1. Put business logic in controllers
2. Call repositories directly from controllers
3. Expose internal error details (stack traces, DB errors)
4. Use verbs in URLs

### ✅ I will ALWAYS:
1. Validate input before calling UseCase
2. Map DomainError types to appropriate HTTP status codes
3. Use plural nouns for resources
4. Return consistent error format: `{ error: "message" }`
