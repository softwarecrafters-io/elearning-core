---
description: Inside-Out TDD development approach
alwaysApply: true
---

# Inside-Out TDD Development

Follow the TDD cycle defined in @.cursor/rules/practices-tdd.mdc for each layer applying @.cursor/rules/practices-testing.mdc

## Development Flow

Always develop from the inside out:

```
Domain (Pure logic) ‚Üí UseCase ‚Üí Repository Adapter ‚Üí HTTP
```

Start from the innermost layer (domain) and work outward. This ensures:
- Pure business logic first
- No premature infrastructure decisions
- Testable from the core
- Clear dependency flow

---

## Test Strategy by Layer

| Layer | Test Type | Dependencies |
|-------|-----------|--------------|
| Domain (entities, VOs) | Unit | None |
| Domain Services | Unit | None |
| UseCases | Unit | InMemoryRepositories |
| Repository Adapters | Integration | Real DB |
| Application Port Adapters | Integration | Real service/sandbox |
| HTTP/Controllers | E2E | Full stack |

---

## Unit Tests

### Domain Layer (entities, value objects, services)

Pure unit tests with **no dependencies**.

```typescript
// Domain entity test - no dependencies
describe('The Order', () => {
  it('calculates total from line items', () => {
    const order = Order.create(Id.generate());
    order.addItem(product, 2);

    const total = order.calculateTotal();

    expect(total.equals(Money.create(200, 'EUR'))).toBe(true);
  });
});
```

### Use Cases

Unit tests using **InMemoryRepositories** (not mocks).

```typescript
// UseCase test - uses InMemoryRepository
describe('The CreateOrderUseCase', () => {
  it('creates and persists an order', async () => {
    const orderRepository = new InMemoryOrderRepository();
    const productRepository = new InMemoryProductRepository([product]);
    const useCase = new CreateOrderUseCase(orderRepository, productRepository);

    const order = await useCase.execute(productId, 2);

    expect(order.id).toBeDefined();
    expect(await orderRepository.findById(order.id)).toBeDefined();
  });
});
```

---

## Integration Tests

### Repository Adapters

Test against **real database** (use testcontainers or similar).

```typescript
// Repository adapter test - real DB
describe('The MongoOrderRepository', () => {
  it('persists and retrieves an order', async () => {
    const repository = new MongoOrderRepository(testDbConnection);
    const order = Order.create(Id.generate());

    await repository.save(order);
    const retrieved = await repository.findById(order.id);

    expect(retrieved).toBeDefined();
    expect(retrieved?.id.equals(order.id)).toBe(true);
  });
});
```

### Application Port Adapters

Test against **real external services** (sandbox/test environment). No mocks here.

```typescript
// Application port adapter test - real service sandbox
describe('The StripePaymentAdapter', () => {
  it('charges the payment in test mode', async () => {
    const adapter = new StripePaymentAdapter(stripeTestClient);

    const result = await adapter.charge(Money.create(100, 'EUR'), 'tok_visa');

    expect(result.success).toBe(true);
  });
});
```

---

## E2E Tests

### HTTP/Controllers

Test the **full stack** through HTTP.

```typescript
// E2E test - full HTTP request
describe('POST /orders', () => {
  it('creates an order via API', async () => {
    const response = await request(app)
      .post('/orders')
      .send({ productId: 'prod-123', quantity: 2 });

    expect(response.status).toBe(201);
    expect(response.body.id).toBeDefined();
  });
});
```

---

## Mocks Policy

### ‚ùå NEVER mock:
- Repositories (use InMemoryRepository instead)
- Domain entities or value objects
- Domain services
- External service adapters in integration tests (use real sandbox)

### ‚úÖ Stubs/Spies ONLY in:
- UseCase tests when the UseCase depends on an external service port
- Use stubs to control return values, spies to verify calls

```typescript
// UseCase test with external service - stubs allowed
describe('The ProcessPaymentUseCase', () => {
  it('processes payment and notifies', async () => {
    const orderRepository = new InMemoryOrderRepository([order]);
    const paymentGateway = stubPaymentGateway({ success: true });
    const notifier = spyNotifier();
    const useCase = new ProcessPaymentUseCase(orderRepository, paymentGateway, notifier);

    await useCase.execute(orderId, paymentDetails);

    expect(notifier.notifyPaymentReceived).toHaveBeenCalledWith(orderId);
  });
});
```

---

## TDD Cycle in Inside-Out Development

Follow the 5-step TDD cycle defined in @.cursor/rules/practices-tdd.mdc for each layer:

### 0. ü§î REASON
- Identify the cases for the current layer
- Start with the simplest case
- Write cases as TODO comments in the test file

### 1. üî¥ RED
- Write one failing test for the simplest case
- Minimum code to compile, then see it fail

### 2. üü¢ GREEN
- Implement minimum code to pass the test
- Follow TPP (Transformation Priority Premise)

### 3. üîµ REFACTOR
- Clean up while keeping tests green
- Apply design rules

### 4. üîÑ RE-EVALUATE
- Mark case as done
- Pick next simplest case
- Repeat until layer is complete, then move outward

---

## Inside-Out Layer Progression

```
1. Start with Domain value objects
   -> TDD cycle for each value object behavior

2. Then with Domain entities
   -> TDD cycle for each entity behavior

3. Build InMemoryRepositories
   -> TDD cycle for repository behavior

4. Add Domain Services (if needed)
   -> TDD cycle for complex domain logic

5. Build UseCases
   -> TDD cycle using InMemoryRepositories

6. Implement Repository Adapters
   -> Integration tests with real DB

7. Add External Service Adapters
   -> Integration tests with real sandbox

8. Wire up HTTP/Controllers
   -> E2E tests for full flow
```

---

## Non-Negotiable Rules

### ‚ùå I will NEVER:
1. Mock repositories in UseCase tests (use InMemory implementations)
2. Start development from infrastructure (outside-in)
3. Write integration tests for domain logic
4. Skip unit tests and go straight to E2E
5. Mock external services in adapter integration tests

### ‚úÖ I will ALWAYS:
1. Start from Domain, then UseCase, then Infrastructure
2. Use InMemoryRepositories for UseCase unit tests
3. Test repository adapters against real databases
4. Test external service adapters against real sandboxes
5. Only use stubs/spies in UseCase tests for external service ports
