---
description: Rules for domain value objects
globs: ["**/domain/value-objects/**/*.ts"]
alwaysApply: false
---

# Value Objects

Value Objects are **immutable** objects defined by their **attributes**, not by identity. Two value objects are equal if all their attributes are equal.

## Characteristics

- **Immutability**: Once created, they cannot be changed
- **Equality by value**: Two VOs are equal if their attributes are equal
- **Self-validation**: Validate their own constraints at creation
- **No identity**: They don't have a unique identifier
- **Side-effect free**: Methods return new instances instead of mutating
- **Serializable**: Provides `toPrimitives()` method

## The Id Value Object

Use a simple `Id` value object for all entity identifiers. One generic `Id` for everything.

```typescript
export class Id {
  private constructor(readonly value: string) {}

  static create(value: string): Id {
    if (!value || value.trim() === '') {
      throw new Error('Id cannot be empty');
    }
    return new Id(value);
  }

  static generate(): Id {
    return new Id(crypto.randomUUID());
  }

  equals(other: Id): boolean {
    return this.value === other.value;
  }

  toPrimitives(): string {
    return this.value;
  }
}
```

## Structure

```typescript
export class Money {
  private constructor(
    readonly amount: number,
    readonly currency: string
  ) {}

  static create(amount: number, currency: string): Money {
    if (amount < 0) {
      throw new Error('Amount cannot be negative');
    }
    if (!['EUR', 'USD', 'GBP'].includes(currency)) {
      throw new Error('Invalid currency');
    }
    return new Money(amount, currency);
  }

  static zero(currency: string = 'EUR'): Money {
    return new Money(0, currency);
  }

  add(other: Money): Money {
    if (this.currency !== other.currency) {
      throw new Error('Cannot add money with different currencies');
    }
    return new Money(this.amount + other.amount, this.currency);
  }

  equals(other: Money): boolean {
    return this.amount === other.amount && this.currency === other.currency;
  }

  toPrimitives(): { amount: number; currency: string } {
    return { amount: this.amount, currency: this.currency };
  }
}
```

## Immutability

Operations must return **new instances**, never mutate the original.

```typescript
// ⚠️ WORSE - Mutating the value object
class Money {
  add(other: Money): void {
    this.amount += other.amount; // ❌ Mutation
  }
}

// ✅ BETTER - Returning a new instance
class Money {
  add(other: Money): Money {
    return new Money(this.amount + other.amount, this.currency);
  }
}
```

## Self-Validation

Value objects validate their constraints in **factory methods**, keeping constructors simple (assignment only).

```typescript
// ✅ GOOD - Simple constructor, validation in factory method
export class Email {
  private constructor(readonly value: string) {}

  static create(value: string): Email {
    if (!value.includes('@')) {
      throw new Error('Invalid email format');
    }
    return new Email(value);
  }

  equals(other: Email): boolean {
    return this.value === other.value;
  }

  toPrimitives(): string {
    return this.value;
  }
}

// ⚠️ WORSE - Validation in constructor
export class Email {
  constructor(readonly value: string) {
    if (!value.includes('@')) {  // ❌ Validation in constructor
      throw new Error('Invalid email format');
    }
  }
}
```

## Common Value Objects

- **Identifier**: `Id` (single generic identifier for all entities)
- **Money**: `Money`, `Price`, `Amount`
- **Dates**: `DateRange`, `Period`
- **Contact**: `Email`, `PhoneNumber`, `Address`
- **Quantities**: `Quantity`, `Percentage`

## Non-Negotiable Rules

### ❌ I will NEVER:
1. Mutate a value object after creation
2. Use setters in value objects
3. Create value objects with invalid state (validate in factory methods)
4. Compare value objects by reference (implement `equals`)
5. Create multiple Id types (use single `Id` value object)
6. Validate in the constructor (use factory methods)

### ✅ I will ALWAYS:
1. Make all properties `readonly`
2. Return new instances from operations
3. Keep constructors simple (assignment only)
4. Validate constraints in factory methods
5. Implement `equals` method for value comparison
6. Implement `toPrimitives()` method for serialization
7. Use private constructor with static factory methods
